#!/usr/bin/env node
/* global console, process */
/**
 * Post-processes railroad diagram SVGs generated by langium-cli
 * 
 * - Cleans SVGs for VitePress theming (removes hardcoded colors)
 * - Generates a manifest.json with rule categories and references
 * - Extracts rule descriptions from grammar JSDoc comments
 * - Adds CSS classes for dark mode support
 * 
 * Run after `npm run langium:generate`
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { GrammarAST } from 'langium';
import { DomainLangGrammar } from '../out/generated/grammar.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const RAILROAD_DIR = path.join(__dirname, '../docs/railroad');

// Rule categories for organizing diagrams (matches grammar structure)
// The order of keys determines the display order in the UI
const RULE_CATEGORIES = {
  'Model Structure': {
    rules: ['Model', 'StructureElement', 'Type'],
    description: 'Core model elements and type definitions',
  },
  'Strategic Design': {
    rules: ['Domain', 'BoundedContext'],
    description: 'DDD strategic design building blocks',
  },
  'Teams & Classifications': {
    rules: ['Team', 'Classification', 'Metadata', 'MetadataEntry'],
    description: 'Team assignments and element categorization',
  },
  'Architecture Mapping': {
    rules: ['ObjectMap', 'ContextMap', 'DomainMap'],
    description: 'Visualization constructs for architecture',
  },
  'Relationships': {
    rules: ['Relationship', 'BoundedContextRef', 'RelationshipArrow', 'IntegrationPattern', 'RelationshipType'],
    description: 'Context and domain relationships',
  },
  'Domain Knowledge': {
    rules: ['DomainTerm', 'AbstractDecision', 'Decision', 'Policy', 'BusinessRule'],
    description: 'Ubiquitous language and business rules',
  },
  'Module System': {
    rules: ['ImportStatement', 'NamespaceDeclaration'],
    description: 'Imports and namespaces',
  },
  'Expressions': {
    rules: ['Assignment', 'QualifiedName'],
    description: 'Low-level syntax constructs',
  },
};

// Rules to skip (terminal rules)
const SKIP_RULES = new Set(['ID', 'STRING', 'INT', 'DESCRIPTION', 'WS', 'ML_COMMENT', 'SL_COMMENT']);

/**
 * Get category for a rule name
 */
function getCategoryForRule(ruleName) {
  for (const [category, config] of Object.entries(RULE_CATEGORIES)) {
    if (config.rules.includes(ruleName)) {
      return category;
    }
  }
  return 'Other';
}

/**
 * Clean SVG for VitePress theming
 */
function cleanSvgForTheming(svg, ruleName) {
  // Add data attribute for rule identification
  svg = svg.replace('<svg ', `<svg data-rule="${ruleName}" `);
  
  // Add class for styling
  svg = svg.replace('class="railroad-diagram"', 'class="railroad-diagram railroad-svg"');
  
  // Remove the embedded style tag (we'll use CSS in VitePress)
  svg = svg.replaceAll(/<style>[\s\S]*?<\/style>/g, '');
  
  // Make colors use CSS variables (for dark mode support)
  // Path strokes
  svg = svg.replaceAll(/stroke:\s*black/g, 'stroke: var(--railroad-stroke)');
  
  // Rect fills (terminal boxes)
  svg = svg.replaceAll(/fill:\s*hsl\(120,\s*100%,\s*90%\)/g, 'fill: var(--railroad-terminal-fill)');
  
  // Rect strokes
  svg = svg.replaceAll(/stroke:\s*black(?=;[^}]*rect)/g, 'stroke: var(--railroad-terminal-stroke)');
  
  // Text fills
  svg = svg.replaceAll(/fill:\s*black/g, 'fill: var(--railroad-text)');
  
  // Background (should be transparent)
  svg = svg.replaceAll(/background-color:[^;]+;?/g, '');
  
  return svg;
}

/**
 * Extract rule references from grammar
 */
function extractRuleReferences(ruleName, grammar) {
  const rule = grammar.rules.find(r => r.name === ruleName);
  if (!rule || !GrammarAST.isParserRule(rule)) return [];
  
  const refs = new Set();
  
  function walk(element) {
    if (!element) return;
    
    if (GrammarAST.isRuleCall(element) && element.rule?.ref) {
      const refName = element.rule.$refText;
      if (!SKIP_RULES.has(refName)) {
        refs.add(refName);
      }
    }
    
    // Walk children
    if ('elements' in element && Array.isArray(element.elements)) {
      for (const child of element.elements) {
        walk(child);
      }
    }
    if ('terminal' in element) {
      walk(element.terminal);
    }
    if ('definition' in element) {
      walk(element.definition);
    }
  }
  
  if (rule.definition) {
    walk(rule.definition);
  }
  
  return Array.from(refs);
}

// Top-level await
console.log('ðŸŽ¨ Post-processing railroad diagrams...\n');

// Load grammar to extract references
const grammar = DomainLangGrammar();

// Read the .langium source file to extract JSDoc comments
const langiumPath = path.join(__dirname, '../src/domain-lang.langium');
const langiumSource = await fs.readFile(langiumPath, 'utf-8');

// Build a map of rule descriptions from grammar JSDoc comments
const ruleDescriptions = extractJSDocDescriptions(langiumSource);

/**
 * Extract JSDoc descriptions for rules from the .langium source file
 */
function extractJSDocDescriptions(source) {
  const descriptions = new Map();
  
  // Match JSDoc comments followed by rule definitions at the start of a line
  // This pattern ensures we don't match inline comments within rule definitions
  // Pattern: newline + /** ... */ + newline + optional 'entry' + rule name + colon
  const jsdocPattern = /\n\/\*\*\s*([\s\S]*?)\s*\*\/\s*\n(?:entry\s+)?(\w+)\s*:/g;
  
  let match;
  while ((match = jsdocPattern.exec(source)) !== null) {
    const [, jsdocContent, ruleName] = match;
    
    // Parse JSDoc content - get first line/sentence as description
    const description = jsdocContent
      .split('\n')
      .map(line => line.replace(/^\s*\*\s?/, '').trim())
      .filter(line => line && !line.startsWith('@'))
      .join(' ')
      .trim();
    
    // Take first sentence
    const firstSentence = description.match(/^[^.!?]+[.!?]?/);
    if (firstSentence) {
      descriptions.set(ruleName, firstSentence[0].trim());
    } else if (description) {
      descriptions.set(ruleName, description.substring(0, 100).trim());
    }
  }
  
  return descriptions;
}

// Read all SVG files from the railroad directory
let files;
try {
  files = await fs.readdir(RAILROAD_DIR);
} catch {
  console.error(`Error: Railroad directory not found at ${RAILROAD_DIR}`);
  console.error('Run "npm run langium:generate" first.');
  process.exit(1);
}

const svgFiles = files.filter(f => f.endsWith('.svg'));

if (svgFiles.length === 0) {
  console.error('No SVG files found. Run "npm run langium:generate" first.');
  process.exit(1);
}

console.log(`Found ${svgFiles.length} SVG files to process.\n`);

// Build category order and descriptions from RULE_CATEGORIES
const categoryOrder = Object.keys(RULE_CATEGORIES);
const categoryDescriptions = Object.fromEntries(
  Object.entries(RULE_CATEGORIES).map(([name, config]) => [name, config.description])
);

const manifest = {
  generatedAt: new Date().toISOString(),
  version: '1.0.0',
  categoryOrder,
  categoryDescriptions,
  categories: {},
  rules: {},
};

// Process each SVG
for (const file of svgFiles) {
  const ruleName = path.basename(file, '.svg');
  const filePath = path.join(RAILROAD_DIR, file);
  
  // Read and clean SVG
  let svg = await fs.readFile(filePath, 'utf-8');
  svg = cleanSvgForTheming(svg, ruleName);
  await fs.writeFile(filePath, svg);
  
  // Add to manifest
  const category = getCategoryForRule(ruleName);
  
  if (!manifest.categories[category]) {
    manifest.categories[category] = [];
  }
  manifest.categories[category].push(ruleName);
  
  manifest.rules[ruleName] = {
    name: ruleName,
    category,
    file: `${ruleName}.svg`,
    description: ruleDescriptions.get(ruleName) || '',
    references: extractRuleReferences(ruleName, grammar),
  };
  
  console.log(`  âœ“ ${ruleName}`);
}

// Sort rules within categories
for (const category of Object.keys(manifest.categories)) {
  manifest.categories[category].sort();
}

// Write manifest
await fs.writeFile(
  path.join(RAILROAD_DIR, 'manifest.json'),
  JSON.stringify(manifest, null, 2)
);
console.log(`\n  âœ“ manifest.json`);

console.log(`\nâœ… Processed ${svgFiles.length} railroad diagrams.`);

// Print summary
console.log('\nCategories:');
for (const [category, rules] of Object.entries(manifest.categories)) {
  console.log(`  ${category}: ${rules.length} rules`);
}
